<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-2022-JP">
 <title> 計算機プログラムの構造と解釈 問題の解</title>
</head>
<body bgcolor="white" vlink="ff0000">
<font color="red">λ</font>1.1節<br><br>
<a href="#ex1.01">問題 1.1</a>　
<a href="#ex1.02">問題 1.2</a>　
<a href="#ex1.03">問題 1.3</a>　
<a href="#ex1.04">問題 1.4</a>　
<a href="#ex1.05">問題 1.5</a>　<br>
<a href="#ex1.06">問題 1.6</a>　
<a href="#ex1.07">問題 1.7</a>　
<a href="#ex1.08">問題 1.8</a>　<br><br>
<a name="ex1.01">問題 1.1</a><br>
<pre>10 ==&gt; 10

(+ 5 3 4) ==&gt; 12

(- 9 1) ==&gt; 8

(/ 6 2) ==&gt; 3

(+ (* 2 4) (- 4 6)) ==&gt; 6

(define a 3)

(define b (+ a 1))

(+ a b (* a b)) ==&gt; 19

(= a b) ==&gt; false

(if (and (&gt; b a) (&lt; b (* a b)))
    b
    a) ==&gt; 4

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25)) ==&gt; 16

(+ 2 (if (&gt; b a) b a)) ==&gt; 6

(* (cond ((&gt; a b) a)
         ((&lt; a b) b)
         (else -1))
   (+ a 1)) ==&gt; 16
</pre>
<a name="ex1.02">問題 1.2</a><br>
<pre>(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
</pre>
<a name="ex1.03">問題 1.3</a><br>
<pre>(define (sumsqr a b c)
 (cond ((and (&gt;= b a) (&gt;= c a)) (+ (* b b) (* c c)))
       ((and (&gt;= c b) (&gt;= a b)) (+ (* c c) (* a a)))
       ((and (&gt;= a c) (&gt;= b c)) (+ (* a a) (* b b)))))

または
(define (sumsqr a b c)
 (if (&gt; a b) 
     (+ (* a a) (if (&gt; b c) (* b b) (* c c)))
     (+ (* b b) (if (&gt; a c) (* a a) (* c c)))))

または
(define (sumsqr a b c)
 (+ (* a a) (* b b) (* c c) 
    (- (* (min a b c) (min a b c)))))
</pre>
<a name="ex1.04">問題 1.4</a><br>
<pre>(define (a-plus-abs-b a b)
  ((if (&gt; b 0) + -) a b))
の本体は, まず演算子のif式が最初に評価され, b&gt;0なら+, そうでなければ-が返る. 
従って本体の式は b&gt;0 なら (+ a b) そうでなければ (- a b)となる.
例えば
(a-plus-abs-b 3 5) ==&gt; 8
(a-plus-abs-b 3 -5) ==&gt; 8
</pre>
<a name="ex1.05">問題 1.5</a><br>
<pre>作用的順序で(test 0 (p))を評価すると, 引数0と(p)の評価にとりかかる. pは(p)と定
義されているから, この評価は終らない. 従って(test 0 (p))の評価も終らない.

一方, 正規的順序の評価では, xとyは評価されないままtestに渡される. 

testの中のif式の述語(= x 0)の評価でxが必要になった時にxが評価され, xは0であるこ
とが分り, 述語は真となり, 帰結部0が返される. yは評価されない.
</pre>
<a name="ex1.06">問題 1.6</a><br>
<pre>述語(good-enough? guess x)が真になっても, new-ifは代替部
(sqrt-iter (impreve guess x) x)
を評価しようとするので, 停止しない. 
</pre>
<a name="ex1.07">問題 1.7</a><br>
<pre>本文にあるsqrtのプログラムでは

(sqrt 2) ==&gt; 1.4142156862745097

(sqrt 0.02) ==&gt; .1444238094866232

(sqrt 0.0002) ==&gt; .03335281609280434

また大きい方は

(sqrt 200000000000000000000) good-enough?が真にならず停止しなくなる. 
そこで相対誤差による評価に変更する. 

(define (sqrt x)
  (define (improve guess)
    (define (average x y)
      (/ (+ x y) 2))
    (average guess (/ x guess)))
  (define (sqrt-iter <font color="red">last-guess next-guess</font>)
    (define (good-enough?)
      (&lt; (abs <font color="red">(/ (- last-guess next-guess) next-guess)</font>)
         0.001))
    (if (good-enough?)
        next-guess
        (sqrt-iter <font color="red">next-guess (improve next-guess)</font>)))
  (sqrt-iter <font color="red">1.0 (improve 1.0)</font>))

この改良プログラムでは

(sqrt 0.0002) ==&gt; 1.4142135623738401e-2

(sqrt 0.000002)  ==&gt; 1.4142135626178485e-3

(sqrt 20000000000000000.0)  ==&gt; 141421356.23732778

と無事に計算出来る. 

</pre>
<a name="ex1.08">問題 1.8</a><br>
<pre>(define (cube-root x)
  (define (good-enough? guess x)
    (&lt; (abs (- (* guess guess guess) x)) 0.001))
  (define (improve guess x)
    (/ (+ (/ x guess guess) guess guess) 3))
  (define (cube-root-iter guess x)
    (if (good-enough? guess x)
        guess
        (cube-root-iter (improve guess x) x)))
  (cube-root-iter 1.0 x))

(cube-root 8)  ==&gt; 2.000004911675504

(cube-root 1729)  ==&gt; 12.00231441503121
</pre>

<br>
<!--a name="ex1.02"--><!--問題 1.2--><br>
<!--a name="ex1.03"--><!--問題 1.3--><br>
<!--a name="ex1.04"--><!--問題 1.4--><br>
<!--a name="ex1.05"--><!--問題 1.5--><br>
<!--a name="ex1.06"--><!--問題 1.6--><br>
<!--a name="ex1.07"--><!--問題 1.7--><br>
<!--a name="ex1.08"--><!--問題 1.8--><br>
</body><!--a name="ex1.01"--><!--問題 1.1--></html>