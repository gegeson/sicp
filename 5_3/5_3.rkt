15:54->16:23
今回もまた一週間ぶり
ガベージコレクションの話。今回も読むだけにする。

16:34->17:32
ストップアンドコピーアルゴリズムがぜんぜんわからん
+3m
17:45->18:12

ここの解説で少し氷解

"Implementation of a stop-and-copy garbage collector

the-carsとthe-cdrsのベクタのペアを２セット用意していて、セルが無くなるまではその片方を使用する。
consしようとして現在使用中のペアのセルを使い切っていた場合には、rootから辿れる全てのセルをもう片方のペアの方にコピーする。
そうするとrootからアクセス出来ないゴミはコピーされないため、コピー後のペアには空きが出来る筈。

セルをコピーする際には元載せるにはコピーが済んでいる目印とコピー先のアドレスを書き込んでおく。
ポインタを辿ってセルをコピーして行く際にはコピーされたセルに入っているポインタはまだ以前のアドレスを指している。
ポインタの先がまだコピーされていなければそれをコピーしてポインタも更新する。ポインタの先が既にコピーされていたら新しいアドレスでポインタを更新する。"
http://d.hatena.ne.jp/tetsu_miyagawa/20150110/1420849534
---
上が非常にわかりやすく、疑問が完全に解決できた

図にある例でトレースしてみよう。
"注意。p1はコピー元の添字1番を指し、p1' はコピー先の添字1番を指している。"
"注意2。/はrootレジスタが指していない任意の値。"

レジスタ: p1
root: p1

コピー元
添字:  0  1  2  3  4  5  6  7
cars  /  p5 n3 /  n4 n1 /  n2
cdrs  /  p2 p4 /  e0 p7 /  e0

まず、rootにあるもの（今回はp1だけ）から参照できる、
添字1の要素をコピー先にコピーし、freeをインクリメントする

コピー先
free: 1
scan: 1

添字:  0  1  2  3  4  5  6  7
cars  p5' /
cdrs  p2' /
---
次に、p5とp2でコピー元を参照し、それもコピーしつつ、
コピーできたらp5, p2をコピーした先に更新する、という風にやっていく
やりきった形がこうなる

free: 5
scan: 5

コピー先
添字:  0   1   2   3   4   5   6   7
cars  p1' n1  n3  n2 n4
cdrs  p2' p3' p4' e0 e0
---
上の例だと遭遇済みなものに当たる事はなかったが、
例えばこういう形だった場合（rootがp1であり、rootのコピーは既に済んでいる）

コピー元
添字:  0  1  2  3  4  5  6  7
cars  /  p5 n3 /  n4 n1 /  n2
cdrs  /  p5 p4 /  e0 p7 /  e0

コピー先
添字:  0  1  2  3  4  5  6  7
cars  p5 /
cdrs  p5 /

carの処理を終えるとこうなり、

コピー元
添字:  0  1   2  3   4   5   6  7
cars  /  済  n3  /  n4  n1  /  n2
cdrs  /  p1' p4  /  e0  p7  /  e0

コピー先
添字:  0   1  2  3  4  5  6  7
cars  p1' n1
cdrs  p5  p3

cdrの処理に進もうとすると、
[済]にぶつかり、p1' を得るので、
p1' に更新する。
後は同じ。

コピー元
添字:  0  1  2  3  4  5  6  7
cars  /  済 n3 /  n4 n1 /  n2
cdrs  /  p1' p4 /  e0 p7 /  e0

コピー先
添字:  0   1  2  3  4  5  6  7
cars  p1' n1
cdrs  p1' p3

後は同じなので略。
