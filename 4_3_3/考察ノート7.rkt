今度これやってみよう
12:29->12:58
+30m
20:42->20:48
通勤中や寝る前にも考えてたので+30mした
色々間違えてたので一回全消ししてる
脳内トレースを何度かやったが詰まるところがなかったので、継続の動きは完全に掴めてると思う

とりあえずポイントは、
amb評価時に受け取った失敗継続は、
amb呼び出し時の失敗継続ではなくクロージャの変数として保存され、
ambが空になった時に呼ばれる。
そしてamb呼び出し時の失敗継続はamb選択肢のcdrとなる。
ambが複数回呼ばれる場合は、
一回目のambが空になった場合→デフォルト失敗継続
一回目のambに渡る失敗継続→amb選択肢のcdr
二回目のambが空になった場合→一回目のambのcdr
二回目のambに渡る失敗継続→二回目のamb選択肢のcdr
という風になっている。
このシステムのおかげで、
ambの重ねがけによる分岐が表現できる。

下のだと、
x = 0, y = 0 で失敗したら、
x = 0, y = 1 が呼ばれ、
それでも失敗したら、
yのambのcdrが空だからxのcdrを呼ぶ失敗継続を呼んで
x = 1, y = 0
という感じ
x = 1, y = 1
のあとにtry-againすると、
まずyが空になってxのcdrを呼び、
xも空になるのでx（一番上のamb）でセットされたデフォルト失敗継続が呼ばれて処理が終了する。
定性的にはこんな感じ
追いかけようと思えばもっと詳細に追いかけられるが、本質はこんなもん

(define (require p)
  (if (not p) (amb)))

(define x false)
(define y false)

(begin
  (set! x (amb 0 1))
  (set! y (amb 0 1))
  (set! y (+ y 1))
  (require (= y 2))
  (x y))
