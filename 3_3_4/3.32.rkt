20m+
18:13->19:18

解答をいきなり見たが、多分、ググって出てきた解答は間違えている。
現象を説明できてない。
というわけで実験＆考察。
----------
一番下にも書いたが、
一言でこの現象をまとめると、
「先入れ先出しでないと、中間結果が誤って出力されるケースがある」
ということだと思う。
-----------
実際にキューをデキューにすげ替えてインターフェイスいじって後入れ先出し（実質スタック）に変化させた上で実行してみた
3.32検証1.rkt が後入れ先出しver,
3.32検証2.rktが先入れ先出しverである。
実験結果をこのファイルの一番下にまとめた。
------------
重大なポイント。
まず、
(set-signal! in-1 0)
(set-signal! in-2 1)
は
「キューに登録されて、その順に実行される」わけではない！
即時実行される。

現に、（実験すると）後入れ先出しであろうと先入れ先出しであろうと、
(set-signal! in-1 1)
(set-signal! in-2 1)
すると普通に in-1 → in-2 の順で結果が出力されるし、
実装を見てもキューに登録というふうにはなっていない。

ではなにがキューに登録されるのか、というと、
and-action-procedureの呼び出しである（andの結果が変わる時に限られるが）

一番下に載せた結果を見つつ検証してみよう。
---------------------------------
in-1 0
in-2 1
から、
in-1 1
in-2 0
になる時、

まず、
in-1 1
in-2 1
となり、
out = (in-1 and in-2 -> 1)
がキューに登録され、
in-1 1
in-2 0
out = (in-1 and in-2 -> 0)
がキューに登録される。

先入れ先出しでは、後に出てくる方が最後に呼び出される。
つまり、まず
out = (in-1 and in-2 -> 1)
が呼ばれ、
次に
out = (in-1 and in-2 -> 0)
が呼ばれる、という順である。

一方、後入れ先出しでは、後に出てくる方は最初に呼び出されるので、

まず、
out = (in-1 and in-2 -> 0)
が呼ばれ、
次に
out = (in-1 and in-2 -> 1)
が呼ばれる、という順である。

ここで、
out = (in-1 and in-2 -> 0)
は初期値から値が変わっていないのでprobeには出力されない。
したがって、実際の出力は
out 6 New-value = 1
だけである。
-------------------------------------
一言でこの現象をまとめると、
「先入れ先出しでないと、中間結果が誤って出力されるケースがある」
ということだと思う。
安全のために、最後に得た値をいつも最後に得たい。
--------------------------------------
(define in-1 (make-wire))
(define in-2 (make-wire))
(define out (make-wire))
(probe 'in-1 in-1)
(probe 'in-2 in-2)
(probe 'out out)
(and-gate in-1 in-2 out)

(set-signal! in-1 0)

(set-signal! in-2 1)

(propagate)

(set-signal! in-1 1)

(set-signal! in-2 0)

(propagate)
---結果（後入れ先出し）------------------------------
'ok
'done
in-2 0 New-value = 1
'done
'done
in-1 3 New-value = 1
'done
in-2 3 New-value = 0
'done
out 6 New-value = 1
'done
[Finished in 0.388s]
---結果（先入れ先出し）-----------------
'ok
'done
in-2 0 New-value = 1
'done
'done
in-1 3 New-value = 1
'done
in-2 3 New-value = 0
'done
out 6 New-value = 1
out 6 New-value = 0
'done
[Finished in 0.38s]
