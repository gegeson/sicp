14m
+
19:42->20:44

検証用コードが
3.31検証1.rkt
3.31検証2.rkt

あと画像でないと説明しづらいので今回は初の画像付き。
画像は
3.31.検証1.png
3.31.検証2.png
を参照。

これは3.30を解き終えてからしばらくするまでコピペミスしていて、その時にかなり考察したのですぐにわかった。

まず大前提
回路アクション（入力に対して出力を計算し、出力の値を更新するアクション）は、
1.線が回路にセットされた時
2.入力としてセットされた線の値が変化した時
のいずれかにしか呼び出されない。

そして、accept-action-procedure!でprocをなくすということは、
これにおける1.をなくすことを意味する。

これを踏まえて画像「3.31.検証1.jpg」と「3.31.検証2.jpg」を見てほしい。
①、のように○になっているのは値が変化した時、かつ値が1、という意味。

inverterは0を受け取って1を返すから、inverterに関しては最初の入力全部0の時でも1を返しうる。
にも関わらず、
1.最初の状態は全部0のままとする
2.しかも、以降の変更で出力を計算するのは入力に変化が訪れたときだけにする
この2つの条件があるせいで、おかしな結果になる。
ということ。

ちなみに、3.29で作ったANDとNOTで作ったORについてはもっと面白い現象があり、
今度ははっきりと異なる結果を返すようになってしまう。
具体的には最初の1回だけに限っては、信号を送って反映されるのに（本来なら7ディレイで済むはずが）16ディレイかかるようになる。
この結果の比較については3.29.rktの一番下に書き足した。

--3.31検証1.rkt、accept-action-procedure!を元のままにした版の結果---

sum 0  New-value = 0
carry 0  New-value = 0'ok
'done

sum 8  New-value = 1'done
'done

carry 11  New-value = 1
sum 16  New-value = 0'done
[Finished in 0.646s]

--3.31検証2.rkt、3.31のためにaccept-action-procedure!を書き換えた版の結果---

'ok
'done
'done
'done

carry 11  New-value = 1'done
[Finished in 0.419s]
