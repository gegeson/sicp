21:56->22:23
7:15->7:20

「実際のところ、内部定義が本体の先頭に来て、
定義された変数に対する値の式の評価が定義された変数をひとつも実際には使わない手続きの場合、
ここでの逐次評価メカニズムは同時定義を直接実装したメカニズムと同じ結果を返します」

初めて真鍋訳がわかりづらいと思ったけど、defineの実装を見に行ったら一応疑問が解けた。

(define a
  (define (square x) (* x x))
  (square 2))
まず、こういうものはこのS式を読み込んだ時点で (* 2 2) を実行する。
一方、
(define (b x)
  (define (square x) (* x x))
  (if (> x 2) (square x) x))

こういう式なら、定義時点で実際に(* 2 2)が実行されることはない。

これを踏まえた上で、
「内部定義が本体の先頭に来て」
はまあ意味どおり。
「定義された変数に対する値の式の評価が定義された変数をひとつも実際には使わない手続きの場合」
これは、上のbのように、式を評価した時点ではまだ手続きを使う段階にない関数、のことを言ってるんだと思う。
そういう場合は、一つ一つ順番に定義したというより、まったく同時に定義したとみなせてしまう、ということ。


この下の変形がどう問題を解決してるんだろう。

(lambda ⟨vars⟩
  (define u ⟨e1⟩)
  (define v ⟨e2⟩)
  ⟨e3⟩)


(lambda ⟨vars⟩
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (set! u ⟨e1⟩)
    (set! v ⟨e2⟩)
    ⟨e3⟩))

http://d.hatena.ne.jp/tetsu_miyagawa/20131214/1387029694
>内部定義。
>テキストの評価器はdefineが出て来る度にその定義を環境に保存するが、それとは違う方法を取る事も出来る。
>テキストの例のodd?のスコープは手続きf全体であって、fのスコープのうちodd?が定義されて以降ではない。と言う事はeven?とodd?はあたかも同時に手続きf内に定義されたかの様な動作をしなければならない。
>テキストの実装ではたまたま問題なく動いている。と言うのは全てのdefineが出揃ってから手続きの本体が定義される約束にしているので、それらの手続きが使われる時には全て定義されているから。
>一つの別の方法としてはdefineで関数を定義した時のlambdaへの変換で、本体内のdefineを全て探してletによる変数に変換してしまうと言うもの。set!で拘束する時には参照する変数そのものは必ず存在する事になる。
>ただしこれは関数を定義した時に限って有効で、普通の変数ではやはり前方参照の様な事は実現出来ない。
>更に別の方法としては文法としてあとから定義される変数（や手続き）を参照しては行けないと言うルールにする事も出来る。

やっぱり何の問題をどう解決してるのか、よくわからん。
'*unassigned*にしようが、uがvを呼んでるなら結局エラー出るでしょ。
問題に進めば分かるかな。
